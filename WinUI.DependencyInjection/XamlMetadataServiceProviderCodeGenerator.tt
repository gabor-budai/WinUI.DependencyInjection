<#@ template language="C#" inherits="CodeGenerator" #>
<#@ assembly name="System.Core" #>
// <auto-generated>
#nullable enable

namespace <#=Model.AppMetadataProviderNamespace#>
{
    partial class <#=Model.ClassName#> : <#=MarkupNamespace#>.IXamlMetadataProvider
    {
        <#=GeneratedCodeAttribute#>
        private <#=MarkupNamespace#>.IXamlMetadataProvider? __diXamlMetadataProvider;

        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        private <#=MarkupNamespace#>.IXamlMetadataProvider _DiXamlMetadataProvider => __diXamlMetadataProvider ??= new <#=Model.XamlTypeInfoNamespace#>.XamlMetadataServiceProvider(this);
        
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        <#=MarkupNamespace#>.IXamlType <#=MarkupNamespace#>.IXamlMetadataProvider.GetXamlType(Type type) => _DiXamlMetadataProvider.GetXamlType(type);
        
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        <#=MarkupNamespace#>.IXamlType <#=MarkupNamespace#>.IXamlMetadataProvider.GetXamlType(string fullName) => _DiXamlMetadataProvider.GetXamlType(fullName);
        
        <#=GeneratedCodeAttribute#>
        <#=DebuggerNonUserCodeAttribute#>
        <#=MarkupNamespace#>.XmlnsDefinition[] <#=MarkupNamespace#>.IXamlMetadataProvider.GetXmlnsDefinitions() => _DiXamlMetadataProvider.GetXmlnsDefinitions();
    }
}

namespace <#=Model.XamlTypeInfoNamespace#>
{
    <#=Visibility#> sealed class XamlMetadataServiceProvider : <#=MarkupNamespace#>.IXamlMetadataProvider
    {
        private <#=Model.HasServiceProviderInterface ? Templates.IXamlMetadataServiceProvider.FullName : Model.ClassFullName#> App { get; }
        private <#=MarkupNamespace#>.IXamlMetadataProvider AppProvider { get; }

        public XamlMetadataServiceProvider(<#=Model.HasServiceProviderInterface ? Templates.IXamlMetadataServiceProvider.FullName : Model.ClassFullName#> app)
        {
            // Note: I think this implementation resolved the issue because now only pages can be instantiated by a service provider, and the IServiceProviderIsService is not used in this case.

            // Do not initialize IsService/services here, as they may not be available yet.

            // I used a ScrollView/RTB (or I'd say, a UI element) to display logs. Any UI element is instantiated via the custom XamlMetadataProvider.
            // The custom XamlMetadataProvider checks whether the underlying type is a registered service. When the Host is built, it logs its creation.
            // If a logger uses any UI element, the custom XamlMetadataProvider will activate it, but at this point, the App's Host property isn't assigned.
            // Therefore, the custom XamlMetadataProvider cannot use the IsService property; otherwise, a NullReferenceException will be thrown.
            // If the UI element's IXamlType (retrieved by the default XamlMetadataProvider.GetXamlType) isn't a XamlUserType, no issues will occur.
            // If the IXamlType is a XamlUserType, the custom XamlMetadataProvider cannot resolve it, leading to a NullReferenceException.
            // In this special case, it's recommended to instantiate any UI element lazily or after the Host is built.
            // For example, the visual logger should have a log queue, and when the App is shown, the queue should be processed.

<# if (Debug) { #>
            System.Diagnostics.Debugger.Break();
<# } #>
            App = app;
<# if (Model.IsGetAppProviderImplemented) { #>
            AppProvider = app.GetAppProvider() ?? <#=ThrowNotSupportedException_GetAppProvider#>;
<# } else { #>
            var propertyInfo = typeof(<#=Model.ClassFullName#>).GetProperty("<#=Model.AppProvider#>", global::System.Reflection.BindingFlags.Instance | global::System.Reflection.BindingFlags.Public | global::System.Reflection.BindingFlags.NonPublic) ?? <#=ThrowNotSupportedException_GetAppProvider#>;
            AppProvider = propertyInfo.GetValue(app) as <#=MarkupNamespace#>.IXamlMetadataProvider ?? <#=ThrowNotSupportedException_GetAppProvider#>;
<# } #>
        }

        public object GetRequiredService(global::System.Type type) 
        {
<# if (Model.IsGetRequiredServiceImplemented) { #>
            return App.GetRequiredService(type); 
<# } else if (Model.HasHost) { #>
            return Microsoft.Extensions.DependencyInjection.ServiceProviderServiceExtensions.GetRequiredService(App.Host.Services, type);
<#} else { #>
            <#=ThrowNotSupportedException_GetRequiredService#>;
<# } #>
        }

        private bool TryGetServiceProviderXamlUserType(<#=MarkupNamespace#>.IXamlType? xamlType, [global::System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out  <#=MarkupNamespace#>.IXamlType? serviceProviderXamlUserType)
        {
            serviceProviderXamlUserType = null;
            // Frame.Navigate instantiates pages only, so only Microsoft.UI.Xaml.Controls.Page or its subclasses are redirected.
            if (xamlType?.UnderlyingType.IsSubclassOf(typeof(global::Microsoft.UI.Xaml.Controls.Page)) is null or false) return false;

            // The default provider caches xaml types, but pages are not instantiated too often. After some tests, I observed that GetXamlType is called only once,
            // therefore, no cahcing is implemented.
            serviceProviderXamlUserType = new ServiceProviderXamlUserType(this, xamlType);
            return true;
        }

        public <#=MarkupNamespace#>.IXamlType GetXamlType(global::System.Type type)
        {
            var xamlType = AppProvider.GetXamlType(type);
            if (TryGetServiceProviderXamlUserType(xamlType, out var serviceProviderXamlUserType)) return serviceProviderXamlUserType;
            return xamlType;
        }

        public <#=MarkupNamespace#>.IXamlType GetXamlType(string fullName)
        {
            var xamlType = AppProvider.GetXamlType(fullName);
            if (TryGetServiceProviderXamlUserType(xamlType, out var serviceProviderXamlUserType)) return serviceProviderXamlUserType;
            return xamlType;
        }

        public <#=MarkupNamespace#>.XmlnsDefinition[] GetXmlnsDefinitions() => AppProvider.GetXmlnsDefinitions();        
    }

    <#=Visibility#> sealed class ServiceProviderXamlUserType : <#=MarkupNamespace#>.IXamlType
    {
        public ServiceProviderXamlUserType(<#=Model.XamlTypeInfoNamespace#>.XamlMetadataServiceProvider provider, <#=MarkupNamespace#>.IXamlType xamlUserType)
        {
            Provider = provider;
            XamlUserType = xamlUserType;
        }

        public <#=MarkupNamespace#>.IXamlType XamlUserType { get; }
        public <#=Model.XamlTypeInfoNamespace#>.XamlMetadataServiceProvider Provider { get; }
        public object ActivateInstance() => Provider.GetRequiredService(UnderlyingType);

        public <#=MarkupNamespace#>.IXamlType BaseType => XamlUserType.BaseType;
        public <#=MarkupNamespace#>.IXamlType BoxedType => XamlUserType.BoxedType;
        public <#=MarkupNamespace#>.IXamlMember ContentProperty => XamlUserType.ContentProperty;
        public string FullName => XamlUserType.FullName;
        public bool IsArray => XamlUserType.IsArray;
        public bool IsBindable => XamlUserType.IsBindable;
        public bool IsCollection => XamlUserType.IsCollection;
        public bool IsConstructible => XamlUserType.IsConstructible;
        public bool IsDictionary => XamlUserType.IsDictionary;
        public bool IsMarkupExtension => XamlUserType.IsMarkupExtension;
        public <#=MarkupNamespace#>.IXamlType ItemType => XamlUserType.ItemType;
        public <#=MarkupNamespace#>.IXamlType KeyType => XamlUserType.KeyType;
        public global::System.Type UnderlyingType => XamlUserType.UnderlyingType;
        public void AddToMap(object instance, object key, object value) => XamlUserType.AddToMap(instance, key, value);
        public void AddToVector(object instance, object value) => XamlUserType.AddToVector(instance, value);
        public object CreateFromString(string value) => XamlUserType.CreateFromString(value);
        public <#=MarkupNamespace#>.IXamlMember GetMember(string name) => XamlUserType.GetMember(name);
        public void RunInitializer() => XamlUserType.RunInitializer();
    }
}
